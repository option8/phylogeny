### FileThread 2025.11.04

# REQ: https://github.com/cduck/drawsvg/blob/master/docs/index.md
### find shortest distance from node to node
import sys
import math
import numpy as np

import sys
import os
import math
import drawsvg as draw

### arrays and variables
colors=['#1f77b4','#ff7f0e','#2ca02c','#d62728','#9467bd','#8c564b','#e377c2','#7f7f7f','#bcbd22','#17becf']

filesArray=[]
scoreMatrix=[]
pathsArray=[]
pathLengthArray=[]
matchesArray=[]
fullArray=[]

minRange = 8 # smallest matching region in bytes
#maxRange = 10240 # 10k ought to be enough for anyone
HSize = 1500
VSIZE = 1000 # 3:2 aspect ratio for the output image.
Padding = 50

# python3 $binDir/findPath.py $threadMode $outputFile ${argv[@]} $pathsArray

threadMode = sys.argv[1]
outputFile = sys.argv[2]

# Takes as input a pathsArray of values n^2 long, which is an array of "distance" values between 
# each pair of nodes in a list of n nodes. In this case, it's generated by pbzCompare.sh
# by compressing each item individually and in pairs.

# first n values after outputFile are the files, this is "matrixDimension"
matrixDimension = math.floor(math.sqrt(len(sys.argv[3:])))

filesArray = sys.argv[3:matrixDimension+3]

fullArray = [float(n) for n in sys.argv[matrixDimension+3:]]


### SETUP for drawing

HScale = float(HSize /( matrixDimension - 1))
d = draw.Drawing(HSize+Padding*2, VSIZE+Padding*2, origin=(-1*Padding,-1*Padding)) 
d.set_pixel_scale(1) # for converting SVG to PNG
d.append(draw.Rectangle(-1*Padding, -1*Padding, HSize+Padding*2, VSIZE+Padding*2 , fill='#FFFFFF')) # fill the canvas with white bg



### functions

def findBestPath( threadMode ) :
	global STEP_LENGTHS
	global BEST_STEP_LENGTHS
	STEP_LENGTHS=[]
	global REORDERED_ARRAY
	global bestPath
	bestPath=[]

	if threadMode=="skip":
		# skip the reordering and thread in the order files were given.
		REORDERED_ARRAY = filesArray
	else:
		# break the full array down into rows
		for rowNum in range(0, matrixDimension) :
			rowMatrix=[]
			for colNum in range(0, matrixDimension):
				matrixIndex=rowNum * matrixDimension + colNum
				rowMatrix.append(fullArray[matrixIndex])
		
			scoreMatrix.append(rowMatrix)
		
		
		# brute force finding nearest neighbors in each row
		for startNode in range(0,matrixDimension):
		
			# checklist = 0 - len(scoreMatrix)
			nodeList = [x for x in range(0, matrixDimension)]
			# start with node 0
		#	startNode = 0
			pathLength = 0 
			currentNode = startNode
			currentPath = []
			STEP_LENGTHS.append([])
			
			while len(nodeList) > 0:
				# remove that from the checklist
				if currentNode in nodeList:
					nodeList.remove(currentNode)
					currentPath.append(currentNode)
				else:
					break
				
				minScore=float(1.0)
		
				for candidate in nodeList:
		
					if scoreMatrix[currentNode][candidate] < minScore:
						minScore = scoreMatrix[currentNode][candidate]
						nextNode = candidate
		
				# running tally of path length
				pathLength += minScore
				
				STEP_LENGTHS[startNode].append(minScore)
				# add the step to the array recording step lengths
		
				currentNode = nextNode
		
			pathsArray.append(currentPath)
			pathLengthArray.append(pathLength)
		
		# find shortest complete path length 
		shortestPath=pathLengthArray.index(min(pathLengthArray))

		bestPath=pathsArray[shortestPath]
		bestPath.reverse()
		
		BEST_STEP_LENGTHS=STEP_LENGTHS[shortestPath]
		BEST_STEP_LENGTHS.reverse()
		
		
		REORDERED_ARRAY = [ filesArray[x] for x in bestPath ]
	


def update_progress(progress,total):
	sys.stdout.write('\r[{0} of {1}]'.format(progress,total))
	sys.stdout.flush()


### RESET
def reset():
	matchesArray=[]
	threadArray=[]
	
	global FILES_BYTES_ARRAY
	FILES_BYTES_ARRAY=[]

	global VScale
	VScale = 1

	### Convert binary data to hex
	for fileNum in range(0,len(REORDERED_ARRAY)):

		FILE_TO_READ=open(REORDERED_ARRAY[fileNum],"rb").read()	

		FILES_BYTES_ARRAY.append(FILE_TO_READ[0:].replace(b'\x00\x00',b''))
			
		pVScale = VSIZE/len(FILES_BYTES_ARRAY[fileNum])	# fit the largest file vertically, but scale all files the same amount. 

# Can't do this with original binary size since some are 00 padded or "sparse"
		if pVScale < VScale:
			VScale = pVScale
			

# for each pair of files, find matching segments.

def matchBlocks(  ):	

	for originFile in range(0, len(FILES_BYTES_ARRAY)-1):
		print(f" Completed {originFile} of {len(FILES_BYTES_ARRAY)}") 
		targetFile = originFile+1
		matchCount=0
		matchSum=0
		diffSum=0
		
		lastResult=""
		originByte=0
		
		originLength = len(FILES_BYTES_ARRAY[originFile]) - 1
		maxRange = originLength
		
		print(f" {targetFile}/{len(FILES_BYTES_ARRAY)}")
		while originByte < originLength :
	
			update_progress(originByte, originLength)
	
			for byteLength in range(minRange,maxRange):
		
				if int(originByte + byteLength) < int(originLength) : # don't try to read past the end. oof.
				
					charLength = int(byteLength)
					originChars = int(originByte)
							
					byteBlock = FILES_BYTES_ARRAY[originFile][originChars:originChars+charLength] # block of bytes to search for

				# do the actual search	- just for the first instance
					wordIndex = FILES_BYTES_ARRAY[targetFile].find(byteBlock)
							
					if wordIndex != -1:
						byteIndex = int(wordIndex)		
						lastResult= f"{originFile}:{targetFile}\t{byteLength}\t{originByte}\t{byteIndex}"
						
					else:
								
						if len(lastResult) > 0: #success!

							currentMatch=[]
							currentMatch.append(byteLength-1)

							for i in range(0,originFile):
								currentMatch.append(None)

							currentMatch.append(originByte)

							for i in range(0, (targetFile - originFile) - 1):
								currentMatch.append(None)
							
							currentMatch.append(byteIndex)

							for i in range(targetFile, len(FILES_BYTES_ARRAY)-1):
								currentMatch.append(None)
							
#								print(currentMatch)

							matchesArray.append(currentMatch)

							indexDiff=abs(byteIndex - originByte)
							if indexDiff > byteLength:
								indexDiff = byteLength/2
							elif indexDiff == 0:
								indexDiff = byteLength * 2
							else:
								indexDiff = byteLength
							
							matchCount+=1
							matchSum+=indexDiff
							lastResult="" # reset for next go-round
						break
				else: 
					break
				
				
			if len(lastResult) > 0:	### matched on end of file/bytesize loop
				
				byteIndex = int(wordIndex)

				currentMatch=[]
				currentMatch.append(byteLength-1)

				for i in range(0,originFile):
					currentMatch.append(None)

				currentMatch.append(originByte)

				for i in range(0, (targetFile - originFile) - 1):
					currentMatch.append(None)
				
				currentMatch.append(byteIndex)

				for i in range(targetFile, len(FILES_BYTES_ARRAY)-1):
					currentMatch.append(None)

#					print(currentMatch)
				matchesArray.append(currentMatch)
				
				
				indexDiff=abs(byteIndex - originByte)
				if indexDiff > byteLength:
					indexDiff = byteLength/2
				elif indexDiff == 0:
					indexDiff = byteLength * 2
				else:
					indexDiff = byteLength
				
				matchCount+=1
				matchSum+=indexDiff
				
				lastResult="" # reset for next go-round
				
			originByte = originByte+(byteLength-2) # skip ahead past matched area, but overlap last 2 bytes 
		
# for each match found from file n to n+1, look for it in files n+2...
# blocklength, file0loc, file1loc, ...filenloc

def doThreads(  ):
	progress=0

	for blockMatch in matchesArray:
		progress+=1
		update_progress(progress, len(matchesArray))

# find first entry X with a value.
		for x in range(1,len(blockMatch)):
# originFile = X-1
			if blockMatch[x] is None:
				continue
			else:
				originChars=int(blockMatch[x])
				originFile=x-1
				charLength=blockMatch[0]
				byteBlock = FILES_BYTES_ARRAY[originFile][originChars:originChars + charLength] # block of bytes to search for
				break

			
			
def drawThreads() :
	global STEP_LENGTHS
	global HScale
	print(" Generating graph.")
		
	RectX=[]
	
	for fileNum in range(0,len(REORDERED_ARRAY)):
		
		# draw rectangles
		if threadMode != "skip":
			HScale = float(HSize / (min(pathLengthArray) - 1))

	# scale graph to match relative distances between items?
			if fileNum == 0:
				RectX.append(0)
			else:
				RectX.append(float(BEST_STEP_LENGTHS[fileNum] * HScale) + RectX[fileNum-1])
		else:
			RectX.append(fileNum * HScale)
		
		emptyRect = draw.Rectangle(RectX[fileNum] , 0, 10, VSIZE , fill='#CCCCCC', stroke='#000000', stroke_width=1)
		d.append(emptyRect)
	
		# Draw text labels
		line = draw.Line(RectX[fileNum] - 2, VSIZE, RectX[fileNum] - 2, 0, stroke='none')
		d.append(line)
		d.append(draw.Text(os.path.basename(REORDERED_ARRAY[fileNum]), 20, path=line, text_anchor='start'))
	
	colorIndex=0	# for rotating through color palette
	# draw transparent polygon between right side of origin and left side of destination
	progress=0
	for matchArray in matchesArray:
		progress+=1
		update_progress(progress, len(matchesArray))
		boxHeight=matchArray[0]*VScale

		for matchNum in range(1, len(matchArray)):
#			print(matchArray[matchNum])

			fillColor=colors[colorIndex] #matchNum]

			if matchArray[matchNum] != None:
				
				CoordY = matchArray[matchNum]* VScale
			# x, y, width, height

				d.append(draw.Rectangle( RectX[matchNum-1], CoordY, 10, boxHeight, fill=fillColor, stroke_width='none', fill_opacity=.5))

		for matchNum in range(1,len(matchArray)-1): # draw lines back from ends
			fillColor=colors[colorIndex] #matchNum]
#			print(matchArray[matchNum], matchArray[matchNum+1])
			if (matchArray[matchNum] != None ) and (matchArray[matchNum+1] != None ):
				CoordY = matchArray[matchNum]* VScale
				CoordY2 = matchArray[matchNum+1]* VScale
				d.append(draw.Lines(
					RectX[matchNum - 1] + 10, CoordY, 
					RectX[matchNum], CoordY2, 
					RectX[matchNum], boxHeight + CoordY2, 
					RectX[matchNum - 1] + 10, CoordY + boxHeight,
					stroke_width='none', fill=fillColor, close='true', fill_opacity=.25))
						
		colorIndex+=1
		if colorIndex == len(colors):
			colorIndex=0
	d.save_png(outputFile +'.png')
	d.save_svg(outputFile +'.svg')



### Do the needful
findBestPath( threadMode )
reset()
matchBlocks()
doThreads()
drawThreads()

